// This file has been generated by Specta. DO NOT EDIT.

/**
 * Used in the `related` field of a Manga relationships.
 * 
 * <https://api.mangadex.org/docs/static-data/#manga-related-enum>
 */
export type MangaRelation = "adapted_from" | "alternate_story" | "alternate_version" | "based_on" | "colored" | "doujinshi" | "main_story" | "monochrome" | "prequel" | "preserialization" | "same_franchise" | "sequel" | "serialization" | "shared_universe" | "side_story" | "spin_off"

export type TauRpcMangaInputTypes = never

/**
 * Reading statuses for followed manga.
 */
export type MangaReadingStatuses = { result?: ResultType; statuses: { [key: string]: ReadingStatus } }

/**
 * Mapping types to get the new UUIDs from the legacy, numerical, IDs.
 */
export type LegacyMappingType = "chapter" | "group" | "manga" | "tag"

export type UserHistoryEntry = { chapterId: string; readDate: MangaDexDateTime }

/**
 * User roles that define what a user has permission to do.
 * More details at : https://api.mangadex.org/docs/static-data/#user-roles-enum
 */
export type UserRole = "ROLE_ADMIN" | "ROLE_BANNED" | "ROLE_CONTRIBUTOR" | "ROLE_DESIGNER" | "ROLE_DEVELOPER" | "ROLE_FORUM_MODERATOR" | "ROLE_GLOBAL_MODERATOR" | "ROLE_GROUP_LEADER" | "ROLE_GROUP_MEMBER" | "ROLE_GUEST" | "ROLE_MEMBER" | "ROLE_MD_AT_HOME" | "ROLE_POWER_UPLOADER" | "ROLE_PUBLIC_RELATIONS" | "ROLE_STAFF" | "ROLE_UNVERIFIED" | "ROLE_USER" | "ROLE_VIP" | "UNKNOWN"

export type ChapterSortOrder = { chapter: OrderDirection } | { createdAt: OrderDirection } | { publishAt: OrderDirection } | { readableAt: OrderDirection } | { updatedAt: OrderDirection } | { volume: OrderDirection }

export type MangaReadMarkers = UngroupedMangaReadMarkers | GroupedMangaReadMarkers

export type TauRpcOAuthOutputTypes = { proc_name: "login"; output_type: OAuthTokenResponse } | { proc_name: "refresh"; output_type: OAuthTokenResponse }

export type MangaDexErrorResponse = { errors?: MangaDexError_[] }

export type AuthorListParams = { limit?: number | null; offset?: number | null; author_ids?: string[]; name?: string | null; order?: AuthorSortOrder | null; includes?: ReferenceExpansionResource[] }

export type TauRpcAuthOutputTypes = { proc_name: "check"; output_type: CheckTokenResponse }

export type GroupStatisticsObject = { result?: ResultType; statistics: { [key: string]: GroupStatistics } }

export type AtHomeServer = { result?: ResultType; baseUrl: string; chapter: ChapterData }

/**
 * BookWalker URI.
 * 
 * Example: "`series/91701`".
 */
export type BookWalker = string

export type ChapterData = { hash: string; data: string[]; dataSaver: string[] }

/**
 * Manga state for approval.
 * 
 * The purpose of these are to discourage troll entries by requiring staff approval.
 */
export type MangaState = "draft" | "published" | "rejected" | "submitted"

export type UploadSessionFileAttributes = { originalFileName: string; fileHash: string; fileSize: number; mimeType: string; source: UploadSource; version: number }

export type ResultType = "ok" | "error"

export type ChapterAggregate = { chapter: string; id: string; others: string[]; count: number }

export type Limited<T> = { rate_limit: RateLimit; body: T }

export type MangaStatistics = { rating: MangaRating; follows: number; comments: Comments | null }

/**
 * General Api Client information.
 */
export type ApiClientAttributes = { name: string; description: string | null; profile: ApiClientProfile; externalClientId: string | null; isActive: boolean; state: ApiClientState; createdAt: MangaDexDateTime; updatedAt: MangaDexDateTime; version: number }

/**
 * NovelUpdates slug.
 * 
 * Example: "`novel-updates`".
 */
export type NovelUpdates = string

export type TagAttributes = { name: { [key: Language]: string }; description: { [key: Language]: string }; group: TagGroup; version: number }

/**
 * JWT that must be included with requests that require Bearer authentication.
 */
export type AuthTokens = { session: string; refresh: string }

/**
 * General Api Client information.
 */
export type ApiClientSecret = { result?: ResultType; data: string }

export type TauRPCMAngadexAPIError = { result: ResultType; type: string; message: string }

export type ApiClientEditParam = { client_id: string; description?: string | null; version: number }

export type GroupStatistics = { comments: Comments | null }

export type ApiClientGetUniqueParams = { client_id: string; includes?: ReferenceExpansionResource[] }

export type TagGroup = "content" | "format" | "genre" | "theme"

/**
 * General manga information.
 */
export type MangaAttributes = { title: { [key: Language]: string }; altTitles: { [key: Language]: string }[]; description: { [key: Language]: string }; isLocked?: boolean; links: MangaLinks | null; originalLanguage: Language; lastVolume: string | null; lastChapter: string | null; publicationDemographic: Demographic | null; status: MangaStatus; year: number | null; contentRating: ContentRating | null; chapterNumbersResetOnNewVolume?: boolean; latestUploadedChapter: string | null; availableTranslatedLanguages: Language[]; tags: ApiObject<TagAttributes>[]; state: MangaState; createdAt: string; updatedAt: string | null; version: number }

export type UploadSessionFileData<A> = { result?: ResultType; errors: MangaDexError_[]; data: A[] }

export type ReadingStatus = "completed" | "dropped" | "on_hold" | "plan_to_read" | "reading" | "re_reading"

export type MangaDexError = { id: string; status: number; title: string | null; detail: string | null; context: { [key: string]: string } | null }

export type RelatedAttributes = MangaAttributes | ChapterAttributes | CoverAttributes | AuthorAttributes | ScanlationGroupAttributes | TagAttributes | UserAttributes | CustomListAttributes

export type TauRpcAtHomeOutputTypes = { proc_name: "server"; output_type: Limited<AtHomeServer> }

export type OAuthTokenResponse = { access_token: string; expires_in: number; refresh_expires_in: number; refresh_token: string; token_type: string; not_before_policy?: number; session_state: string; scope: string; client_type: ApiClientProfile }

export type MangaSortOrder = { createdAt: OrderDirection } | { followedCount: OrderDirection } | { latestUploadedChapter: OrderDirection } | { relevance: OrderDirection } | { title: OrderDirection } | { updatedAt: OrderDirection } | { year: OrderDirection }

/**
 * The Api Client profile
 */
export type ApiClientProfile = "personal" | "public"

export type AuthorGetUniqueParam = { id: string; includes?: ReferenceExpansionResource[] }

/**
 * The response when refreshing the session JWT.
 */
export type RefreshTokenResponse = { token: AuthTokens; message: string | null }

/**
 * Upload file source.
 */
export type UploadSource = "local" | "remote"

export type TauRpcApiClientOutputTypes = { proc_name: "list"; output_type: Results<ApiObject<ApiClientAttributes>> } | { proc_name: "create"; output_type: ApiData<ApiObject<ApiClientAttributes>> } | { proc_name: "get_unique"; output_type: ApiData<ApiObject<ApiClientAttributes>> } | { proc_name: "edit"; output_type: ApiData<ApiObject<ApiClientAttributes>> } | { proc_name: "delete"; output_type: NoData } | { proc_name: "get_secret"; output_type: ApiClientSecret } | { proc_name: "refresh_secret"; output_type: ApiClientSecret }

export type Comments = { threadId: number; repliesCount: number }

export type ClientInfo = { clientId: string; clientSecret: string }

export type GroupedMangaReadMarkers = { data: { [key: string]: string[] } }

/**
 * 
 * <https://api.mangadex.org/docs/static-data/#relationship-types>
 * 
 * This should only be used with the `type` response field.
 * For use with the `includes[]` query parameter, refer to the [`ReferenceExpansionResource` enum](crate::ReferenceExpansionResource).
 */
export type RelationshipType = "manga" | "chapter" | "cover_art" | "author" | "artist" | "scanlation_group" | "tag" | "user" | "custom_list" | "mapping_id" | "leader" | "member" | "report_reason" | "report" | "upload_session" | "upload_session_file" | "collection" | "manga_relation" | "creator" | "thread" | "api_client" | "unknown"

export type TauRpcAuthorOutputTypes = { proc_name: "list"; output_type: Results<ApiObject<AuthorAttributes>> } | { proc_name: "create"; output_type: Limited<ApiData<ApiObject<AuthorAttributes>>> } | { proc_name: "get_unique"; output_type: ApiData<ApiObject<AuthorAttributes>> } | { proc_name: "edit"; output_type: Limited<ApiData<ApiObject<AuthorAttributes>>> } | { proc_name: "delete"; output_type: Limited<NoData> }

export type Relationship = { id: string; type: RelationshipType; related?: MangaRelation | null; attributes?: RelatedAttributes | null }

export type Results<T> = { result?: ResultType; response: ResponseType; data: T[]; limit: number; offset: number; total: number }

export type MangaDraftsSortOrder = { createdAt: OrderDirection } | { title: OrderDirection } | { updatedAt: OrderDirection } | { year: OrderDirection }

export type AuthorSortOrder = { name: OrderDirection }

/**
 * Languages supported by MangaDex.
 */
export type Language = "ar" | "az" | "bn" | "bg" | "my" | "ca" | "zh-ro" | "zh" | "zh-hk" | "hr" | "cs" | "da" | "nl" | "en" | "eo" | "tl" | "fi" | "fr" | "de" | "el" | "he" | "hi" | "hu" | "id" | "it" | "ja" | "ja-ro" | "kk" | "ko" | "ko-ro" | "la" | "lt" | "ms" | "mn" | "ne" | "kr" | "no" | "fa" | "pl" | "pt-br" | "pt" | "rm" | "ro" | "ru" | "sr" | "sk" | "es" | "es-la" | "sv" | "ta" | "th" | "tr" | "uk" | "vi" | "NULL"

/**
 * Flag to include future updates in the results.
 */
export type IncludeFutureUpdates = "Include" | "Exclude"

export type UploadSessionAttributes = { isCommitted: boolean; isProcessed: boolean; isDeleted: boolean; version: number; createdAt: string; updatedAt: string }

export type TauRpcAuthInputTypes = { proc_name: "check"; input_type: null }

/**
 * "Order by" directions for manga results.
 */
export type OrderDirection = "asc" | "desc"

/**
 * Report reasons for submitting reports to the MangaDex staff.
 */
export type ReportStatus = "accepted" | "autoresolved" | "refused" | "waiting"

/**
 * General chapter information.
 * More details at https://api.mangadex.org/docs/swagger.html#model-ChapterAttributes
 */
export type ChapterAttributes = { title: string; volume: string | null; chapter: string | null; pages: number; translatedLanguage: Language; uploader?: string | null; externalUrl: string | null; version: number; createdAt: MangaDexDateTime; updatedAt: MangaDexDateTime | null; publishAt: string; readableAt: string }

/**
 * API Client state for approval.
 * 
 * The purpose of these are to discourage troll entries by requiring staff approval.
 */
export type ApiClientState = "requested" | "approved" | "rejected" | "autoapproved"

export type LegacyMappingIdAttributes = { type: LegacyMappingType; legacyId: number; newId: string }

export type ApiClientListParam = { limit?: number | null; offset?: number | null; state?: ApiClientState | null; name?: string | null; includes?: ReferenceExpansionResource[] }

export type ForumThreadType = "manga" | "group" | "chapter"

export type UserHistory = { result?: ResultType; ratings: UserHistoryEntry[] }

/**
 * MyAnimeList ID.
 * 
 * Example: "`98436`".
 */
export type MyAnimeList = string

/**
 * Flag to include future updates in the results.
 */
export type IncludeFuturePublishAt = "Include" | "Exclude"

/**
 * Target demographic for manga.
 */
export type Demographic = "shounen" | "shoujo" | "seinen" | "josei" | "none"

export type LoginResponse = { token: AuthTokens }

export type CustomListVisibility = "Public" | "Private"

/**
 * Relationship types for reference expansion.
 * 
 * <https://api.mangadex.org/docs/static-data/#relationship-types>
 * 
 * This should only be used with the `includes[]` query parameter.
 * For response types, refer to the [`RelationshipType` enum](crate::RelationshipType).
 */
export type ReferenceExpansionResource = "manga" | "chapter" | "cover_art" | "author" | "artist" | "scanlation_group" | "tag" | "user" | "custom_list" | "creator" | "reason" | "leader" | "member" | "thread"

export type TauRpcMangaOutputTypes = never

export type CheckUsernameAvailableResponse = { available: boolean }

export type ForumThreadObject<A, T> = { type: T; id: number; attributes: A }

/**
 * Flag to include future updates in the results.
 */
export type IncludeFuturePages = "Include" | "Exclude"

export type GrantTypeSupported = "refresh_token" | "password" | "authorization_code" | "client_credentials"

/**
 * MangaUpdates ID.
 * 
 * Example: "`132515`".
 */
export type MangaUpdates = string

/**
 * API response for a single entity containing an [`ApiObject`] in the `data` field.
 */
export type ApiData<T> = { result?: ResultType; response: ResponseType; data: T }

/**
 * Related link types for a manga.
 */
export type MangaLink = "amz" | "al" | "ap" | "bw" | "cdj" | "ebj" | "engtl" | "kt" | "mu" | "mal" | "nu" | "raw"

export type ChapterStatisticsObject = { result?: ResultType; statistics: { [key: string]: ChapterStatistics } }

export type ApiClientCreateParams = { name: string; description?: string | null; profile?: ApiClientProfile; version?: number | null }

export type UngroupedMangaReadMarkers = { data: string[] }

/**
 * This `RateLimit` struct contains all the data needed for rate limit handling
 * It can be parsed via a [`reqwest::Response`] or [`reqwest::header::HeaderMap`]
 * ```rust
 * use mangadex_api_types_rust::rate_limit::{LIMIT, REMAINING, RETRY_AFTER, RateLimit, RateLimitParseError};
 * use reqwest::header::{HeaderMap, HeaderValue};
 * 
 * fn main() -> Result<(), RateLimitParseError> {
 * let mut headers = HeaderMap::new();
 * headers.append(RETRY_AFTER, HeaderValue::from_static("1698723860"));
 * headers.append(LIMIT, HeaderValue::from_static("40"));
 * headers.append(REMAINING, HeaderValue::from_static("39"));
 * assert_eq!(headers.len(), 3);
 * let rate_limit: RateLimit = TryFrom::try_from(&headers)?;
 * assert_eq!(rate_limit.limit, 40);
 * assert_eq!(rate_limit.remaining, 39);
 * Ok(())
 * }
 * ```
 * 
 */
export type RateLimit = { limit: number; remaining: number; retry_after: MangaDexDateTime }

export type Rating = { rating: number; createdAt: string }

/**
 * Newtype struct for handling datetime fields in MangaDex.
 */
export type MangaDexDateTime = string

/**
 * General author information.
 */
export type AuthorAttributes = { name: string; imageUrl: string | null; biography: { [key: Language]: string }; twitter: string | null; pixiv: string | null; melonBook: string | null; fanBox: string | null; booth: string | null; nicoVideo: string | null; skeb: string | null; fantia: string | null; tumblr: string | null; youtube: string | null; weibo: string | null; naver: string | null; website: string | null; version: number; createdAt: string; updatedAt: string | null }

export type MangaRating = { average?: number | null; bayesian?: number | null; distribution?: { [key: string]: number } }

/**
 * User Settings response.
 */
export type UserSettingsAttributes = { result?: ResultType; updatedAt: string; template: string }

export type ApiClientDeleteParam = { client_id: string; version?: number | null }

/**
 * Response struct for the manga aggregate endpoint (GET `/manga/:id/aggregate`).
 */
export type MangaAggregate = { result?: ResultType; volumes: VolumeAggregate[] }

export type MangaFeedSortOrder = { chapter: OrderDirection } | { createdAt: OrderDirection } | { publishAt: OrderDirection } | { readableAt: OrderDirection } | { updatedAt: OrderDirection } | { volume: OrderDirection }

/**
 * Related links for a manga.
 */
export type MangaLinks = { amz?: string | null; al?: string | null; ap?: string | null; bw?: BookWalker | null; cdj?: string | null; ebj?: string | null; engtl?: string | null; kt?: string | null; mu?: MangaUpdates | null; mal?: MyAnimeList | null; nu?: NovelUpdates | null; raw?: string | null }

/**
 * General cover information.
 */
export type CoverAttributes = { description: string; locale: Language | null; volume: string | null; fileName: string; createdAt: string; updatedAt: string | null; version: number }

export type IsFollowingResponse = { is_following: boolean }

export type ChapterStatistics = { comments: Comments | null }

export type TauRpcAuthorInputTypes = { proc_name: "list"; input_type: { __taurpc_type: AuthorListParams } } | { proc_name: "create"; input_type: { __taurpc_type: AuthorCreateParams } } | { proc_name: "get_unique"; input_type: { __taurpc_type: AuthorGetUniqueParam } } | { proc_name: "edit"; input_type: { __taurpc_type: AuthorEditParams } } | { proc_name: "delete"; input_type: { __taurpc_type: string } }

export type OAuthLoginParams = { username: string; password: string }

export type ReportSortOrder = { createdAt: OrderDirection }

/**
 * Determines the behavior of tag interaction when including or excluding tags in the results.
 */
export type TagSearchMode = "AND" | "OR"

/**
 * User submitted report information.
 */
export type UserReportAttributes = { details: string; objectId: string; status: ReportStatus; createdAt: string }

/**
 * Reading status for a single manga.
 */
export type MangaReadingStatus = { result?: ResultType; status: ReadingStatus }

export type VolumeAggregate = { volume: string; count: number; chapters: ChapterAggregate[] }

export type ResponseType = "collection" | "entity"

export type TauRpcAtHomeInputTypes = { proc_name: "server"; input_type: { __taurpc_type: AtHomeServerParams } }

/**
 * Report reason response object.
 */
export type ReportReasonAttributes = { reason: { [key: Language]: string }; detailsRequired: boolean; category: ReportCategory; version: number }

export type TauRpcApiClientInputTypes = { proc_name: "list"; input_type: { __taurpc_type: ApiClientListParam } } | { proc_name: "create"; input_type: { __taurpc_type: ApiClientCreateParams } } | { proc_name: "get_unique"; input_type: { __taurpc_type: ApiClientGetUniqueParams } } | { proc_name: "edit"; input_type: { __taurpc_type: ApiClientEditParam } } | { proc_name: "delete"; input_type: { __taurpc_type: ApiClientDeleteParam } } | { proc_name: "get_secret"; input_type: { __taurpc_type: string } } | { proc_name: "refresh_secret"; input_type: { __taurpc_type: string } }

/**
 * Flag to include future updates in the results.
 */
export type IncludeExternalUrl = "Include" | "Exclude"

export type ForumThreadAttributes = { repliesCount: number }

export type MangaStatus = "ongoing" | "completed" | "hiatus" | "cancelled"

export type GroupSortOrder = { createdAt: OrderDirection } | { followedCount: OrderDirection } | { latestUploadedChapter: OrderDirection } | { name: OrderDirection } | { relevance: OrderDirection } | { updatedAt: OrderDirection }

export type CustomListAttributes = { name: string; visibility: CustomListVisibility; version: number }

/**
 * Response struct for the manga relation list endpoint (GET `/manga/:id/aggregate`).
 */
export type MangaRelationAttributes = { relation: MangaRelation; version: number }

export type RatingsList = { result?: ResultType; ratings: { [key: string]: Rating } }

export type MangaDexError_ = { id: string; status: number; title: string | null; detail: string | null; context: { [key: string]: string } | null }

/**
 * Placeholder to hold response bodies that will be discarded.
 * 
 * `Result<()>` can't be used with the macro return type because it expects a unit type,
 * so a temporary struct is used.
 * 
 * # Examples
 * 
 * ```text
 * endpoint! {
 * POST "/captcha/solve",
 * #[body] SolveCaptcha<'_>,
 * #[discard_result] Result<NoData> // `Result<()>` results in a deserialization error despite discarding the result.
 * }
 */
export type NoData = { result?: ResultType }

export type CheckTokenResponse = { result?: ResultType; isAuthenticated: boolean; roles: UserRole[]; permissions: string[] }

export type TauRpcOAuthInputTypes = { proc_name: "login"; input_type: { __taurpc_type: OAuthLoginParams } } | { proc_name: "refresh"; input_type: null }

export type ApiObject<A> = { id: string; type: RelationshipType; attributes: A; relationships: Relationship[] }

export type MangaStatisticsObject = { result?: ResultType; statistics: { [key: string]: MangaStatistics } }

export type CoverSortOrder = { createdAt: OrderDirection } | { updatedAt: OrderDirection } | { volume: OrderDirection }

export type AuthorCreateParams = { name: string; biography?: { [key: Language]: string } | null; twitter?: string | null; pixiv?: string | null; melon_book?: string | null; fan_box?: string | null; booth?: string | null; nico_video?: string | null; skeb?: string | null; fantia?: string | null; tumblr?: string | null; youtube?: string | null; weibo?: string | null; naver?: string | null; website?: string | null }

/**
 * Report reasons for submitting reports to the MangaDex staff.
 */
export type ReportCategory = "author" | "chapter" | "manga" | "scanlation_group" | "user"

export type ApiObjectNoRelationships<A> = { id: string; type: RelationshipType; attributes: A }

export type UserSortOrder = { username: OrderDirection }

export type AtHomeServerParams = { chapter_id: string; force_port_443?: boolean | null }

/**
 * Enum for serialization to tag UUID.
 */
export type Tag = "Gore" | "SexualViolence" | "Adaptation" | "Anthology" | "AwardWinning" | "Doujinshi" | "FanColored" | "FourKoma" | "FullColor" | "LongStrip" | "OfficialColored" | "Oneshot" | "UserCreated" | "WebComic" | "Action" | "Adventure" | "BoysLove" | "Comedy" | "Crime" | "Drama" | "Fantasy" | "GirlsLove" | "Historical" | "Horror" | "Isekai" | "MagicalGirls" | "Mecha" | "Medical" | "Mystery" | "Philosophical" | "Psychological" | "Romance" | "SciFi" | "SliceOfLife" | "Sports" | "Superhero" | "Thriller" | "Tragedy" | "Wuxia" | "Aliens" | "Animals" | "Cooking" | "Crossdressing" | "Delinquents" | "Demons" | "Genderswap" | "Ghosts" | "Gyaru" | "Harem" | "Incest" | "Loli" | "Mafia" | "Magic" | "MartialArts" | "Military" | "Monsters" | "MonsterGirls" | "Music" | "Ninja" | "OfficeWorkers" | "Police" | "PostApocalyptic" | "Reincarnation" | "ReverseHarem" | "Samurai" | "SchoolLife" | "Survival" | "VideoGames" | "Shota" | "Supernatural" | "TimeTravel" | "TraditionalGames" | "Vampires" | "Villainess" | "VirtualReality" | "Zombies"

export type ContentRating = "erotica" | "pornographic" | "safe" | "suggestive"

export type MangaDexErrorResponse_ = { result?: ResultType; errors?: MangaDexError[] }

/**
 * General scanlation group information.
 */
export type ScanlationGroupAttributes = { name: string; altNames: { [key: Language]: string }[]; website: string | null; ircServer: string | null; ircChannel: string | null; discord: string | null; contactEmail: string | null; description: string | null; twitter: string | null; mangaUpdates: string | null; focusedLanguages: Language[] | null; locked: boolean; official: boolean; verified: boolean; inactive: boolean; exLicensed?: boolean | null; publishDelay: string | null; version: number; createdAt: MangaDexDateTime; updatedAt: MangaDexDateTime }

/**
 * General user information.
 */
export type UserAttributes = { username: string; roles: UserRole[]; version: number }

export type AuthorEditParams = { id: string; name: string | null; biography?: { [key: Language]: string } | null; twitter?: string | null; pixiv?: string | null; melon_book?: string | null; fan_box?: string | null; booth?: string | null; nico_video?: string | null; skeb?: string | null; fantia?: string | null; tumblr?: string | null; youtube?: string | null; weibo?: string | null; naver?: string | null; website?: string | null; version: number }

const ARGS_MAP = {"mangadex_at_home":"{\"server\":[\"params\"]}","mangadex_author":"{\"edit\":[\"params\"],\"create\":[\"params\"],\"list\":[\"params\"],\"get_unique\":[\"params\"],\"delete\":[\"id\"]}","mangadex_api_client":"{\"edit\":[\"params\"],\"create\":[\"params\"],\"get_secret\":[\"id\"],\"delete\":[\"params\"],\"refresh_secret\":[\"id\"],\"list\":[\"params\"],\"get_unique\":[\"params\"]}","mangadex_auth":"{\"check\":[]}"}
import { createTauRPCProxy as createProxy } from "taurpc"

export const createTauRPCProxy = () => createProxy<Router>(ARGS_MAP)

type Router = {
	'mangadex_api_client': [TauRpcApiClientInputTypes, TauRpcApiClientOutputTypes],
	'mangadex_at_home': [TauRpcAtHomeInputTypes, TauRpcAtHomeOutputTypes],
	'mangadex_auth': [TauRpcAuthInputTypes, TauRpcAuthOutputTypes],
	'mangadex_author': [TauRpcAuthorInputTypes, TauRpcAuthorOutputTypes],
}